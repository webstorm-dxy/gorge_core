# 下一步实现路线图与建议

## 项目背景

gorge_core 是 Gorge 音乐游戏引擎的 gorge 编程语言的 C++ 运行时和框架实现。这是从原有 C# 实现 (`/Users/daxingyi/RiderProjects/gorgecompilertool`) 向 C++ 迁移的一部分，旨在提供更好的性能和原生集成能力。

本文档基于对 C# 项目和现有 C++ 实现的分析，提供下一步的实现路线图和建议。

## 当前状态分析

### C++ 项目已实现功能

1. **类型系统基础**
   - ✅ `GorgeType` - 类型表示类
   - ✅ `BasicType` - 基本类型枚举 (Int, Float, Bool, Enum, String, Object, Interface, Delegate)
   - ✅ `Annotation` - 注解系统

2. **构建系统**
   - ✅ xmake 构建配置
   - ✅ C++20/23 模块支持
   - ✅ 跨平台编译支持 (Windows/macOS/Linux)

3. **外部接口**
   - ✅ FFI (外部函数接口) 用于 C# P/Invoke 调用
   - ✅ 基础的类型创建和查询函数

### 已知问题 (需要优先修复)

1. **泛型实例化方法 (`create_generics_instance_type`)**
   - ❌ **严重**: 数组越界访问风险
   - 文件: `src/objective/gorge_type.cppm:116-139`
   - 影响: 运行时崩溃

2. **委托类型创建 (`Delegate` 静态方法)**
   - ❌ **功能不完整**: 缺少参数处理逻辑
   - 文件: `src/objective/gorge_type.cppm:100-108`

3. **类型相等性比较 (`operator==`)**
   - ❌ **逻辑错误**: 未比较子类型 (`sub_types`)
   - 影响: 类型比较结果不正确

4. **注解系统方法签名 (`Annotation::try_get_metadata`)**
   - ❌ **API 错误**: 错误的 `unique_ptr` 参数类型
   - 文件: `src/objective/annotation.cppm:48-49`

### C# 项目待迁移功能

1. **对象模型**
   - `GorgeObject` - 对象基类
   - `GorgeClass` - 类实现
   - `GorgeInterface` - 接口实现
   - `GorgeEnum` - 枚举实现

2. **运行时环境**
   - `GorgeLanguageRuntime` - 语言运行时
   - 类、接口、枚举的注册和管理

3. **虚拟机**
   - `IntermediateCodeVirtualMachine` - 中间代码虚拟机
   - `IntermediateCode` - 中间代码指令集
   - `VmStack` - 虚拟机栈

4. **原生容器类型**
   - 数组: `IntArray`, `FloatArray`, `BoolArray`, `StringArray`, `ObjectArray`
   - 列表: `IntList`, `FloatList`, `BoolList`, `StringList`, `ObjectList`

5. **注入器系统**
   - `Injector` - 注入器基类
   - `CompiledInjector` - 编译后的注入器

## 实现路线图

### 阶段一：基础修复与对象模型 (1-2周)

**目标**: 修复关键问题，实现对象模型基础

#### 1.1 修复类型系统问题 (高优先级)

| 问题 | 修复方案 | 影响 |
|------|----------|------|
| 泛型实例化数组越界 | 1. 初始化 `sub_types_` 向量大小<br>2. 添加边界检查<br>3. 验证参数数量 | 运行时稳定性 |
| Delegate 方法不完整 | 参考 C# 实现，完整处理参数收集和返回值 | 委托类型功能 |
| 类型相等性比较 | 在 `operator==` 中添加 `sub_types` 比较 | 类型比较正确性 |
| 注解方法签名 | 改为 `bool try_get_metadata(const std::string& name, Metadata& metadata)` | API 可用性 |

#### 1.2 实现对象模型核心

**文件结构**:
```
src/objective/
├── gorge_object.cppm      # 对象基类
├── gorge_class.cppm       # 类实现
├── gorge_class_declaration.cppm  # 类声明元数据
├── gorge_interface.cppm   # 接口实现
└── gorge_enum.cppm        # 枚举实现
```

**核心接口设计**:

```cpp
// GorgeObject 核心方法
export class GORGE_API GorgeObject {
public:
    virtual ~GorgeObject() = default;

    // 字段访问 (按类型和索引)
    virtual int get_int_field(int field_index);
    virtual float get_float_field(int field_index);
    virtual bool get_bool_field(int field_index);
    virtual std::string get_string_field(int field_index);
    virtual GorgeObject* get_object_field(int field_index);

    // 字段设置
    virtual void set_int_field(int field_index, int value);
    virtual void set_float_field(int field_index, float value);
    virtual void set_bool_field(int field_index, bool value);
    virtual void set_string_field(int field_index, const std::string& value);
    virtual void set_object_field(int field_index, GorgeObject* value);

    // 方法调用
    virtual void invoke_method(int method_index);
    virtual void invoke_interface_method(GorgeType* interface_type, int interface_method_id);

    // 反射支持
    virtual int field_index(const std::string& field_name);
    virtual int get_int_field(const std::string& field_name);
    // ... 其他类型字段的命名访问
};
```

#### 1.3 扩展 FFI 接口

新增必要的 FFI 函数:
```c
// 对象创建和销毁
GORGE_API void* CreateGorgeObject(void* class_ptr);
GORGE_API void DeleteGorgeObject(void* object_ptr);

// 字段访问
GORGE_API int GetIntField(void* object_ptr, int field_index);
GORGE_API void SetIntField(void* object_ptr, int field_index, int value);
GORGE_API float GetFloatField(void* object_ptr, int field_index);
GORGE_API void SetFloatField(void* object_ptr, int field_index, float value);
// ... 其他类型字段

// 方法调用
GORGE_API void InvokeMethod(void* object_ptr, int method_index);
```

### 阶段二：运行时环境与容器 (2-3周)

**目标**: 实现运行时管理和基础容器类型

#### 2.1 运行时环境 (`GorgeLanguageRuntime`)

**功能**:
- 类、接口、枚举的注册和管理
- 类型查找和反射支持
- 与 C# 实现的互操作支持

**设计要点**:
- 单例模式或显式传递的运行时上下文
- 支持原生实现和用户定义的上下文
- 类型安全的注册和查找接口

#### 2.2 原生容器类型

**优先级顺序**:
1. 数组类型 (`IntArray`, `FloatArray`, `BoolArray`, `StringArray`, `ObjectArray`)
2. 列表类型 (`IntList`, `FloatList`, `BoolList`, `StringList`, `ObjectList`)

**实现模式**:
- 继承自 `GorgeObject`
- 类型特定的内存布局
- 边界检查和错误处理
- 基本的集合操作接口

#### 2.3 注入器系统 (`Injector`)

**功能**:
- 对象构造和依赖注入
- 编译后的注入器优化
- 与虚拟机指令集成

### 阶段三：虚拟机核心 (3-4周)

**目标**: 实现中间代码虚拟机

#### 3.1 中间代码定义 (`IntermediateCode`)

**指令集设计**:
- 算术运算指令
- 字段访问和赋值指令
- 方法调用和返回指令
- 控制流指令 (跳转、条件分支)
- 本地变量管理指令

#### 3.2 虚拟机实现 (`IntermediateCodeVirtualMachine`)

**核心组件**:
- 指令解码和执行循环
- 虚拟机栈 (`VmStack`) 管理
- 本地变量帧管理
- 方法调用栈管理
- 异常处理机制

#### 3.3 操作数系统 (`IOperand`)

**设计**:
- 统一的数值表示
- 类型安全的操作数访问
- 与 C++ 原生类型的转换

### 阶段四：高级功能与优化 (持续)

**目标**: 完善功能，优化性能

#### 4.1 内存管理
- 自定义分配器优化
- 对象池和缓存机制
- 垃圾回收策略 (可选)

#### 4.2 并发支持
- 线程安全的运行时
- 原子操作支持
- 并行执行模型

#### 4.3 调试和性能分析
- 调试符号支持
- 性能剖析工具
- 内存泄漏检测

#### 4.4 标准库扩展
- 集合类和算法
- I/O 和文件系统支持
- 网络和序列化

## 技术设计与建议

### 内存管理策略

**短期方案**: 使用智能指针 (`std::shared_ptr`, `std::unique_ptr`)
- 优点: 自动内存管理，减少泄漏风险
- 缺点: 性能开销，循环引用风险

**中期方案**: 自定义内存池
- 针对对象类型的内存布局优化
- 减少分配和释放开销
- 更好的缓存局部性

**长期方案**: 分代垃圾回收 (可选)
- 适用于长期运行的应用
- 减少手动内存管理负担

### 错误处理设计

**核心原则**:
1. 使用异常处理不可恢复的错误
2. 使用返回码处理可恢复的错误
3. FFI 接口使用返回码和错误指针

**异常层次**:
```cpp
class GorgeException : public std::runtime_error;
class TypeException : public GorgeException;
class FieldAccessException : public GorgeException;
class MethodInvocationException : public GorgeException;
```

### 性能优化考虑

1. **内联缓存**: 对频繁访问的字段和方法使用缓存
2. **JIT 编译**: 考虑将热点中间代码编译为原生代码
3. **向量化**: 对数组操作使用 SIMD 指令
4. **内存布局**: 优化对象内存布局减少缓存未命中

### 跨平台兼容性

1. **ABI 稳定性**: 确保 FFI 接口的二进制兼容性
2. **编译器兼容**: 测试主流编译器 (GCC, Clang, MSVC)
3. **平台特性**: 隔离平台相关的代码

## 实施优先级和建议

### 立即行动 (第1周)

1. **修复泛型实例化数组越界问题**
   - 这是最严重的运行时风险
   - 修复后可确保类型系统的稳定性

2. **实现 GorgeObject 基类**
   - 提供对象模型的基础设施
   - 可以开始编写对象相关的测试

### 短期目标 (第2-3周)

3. **实现 GorgeClass 和相关元数据**
   - 完成对象模型的核心部分
   - 支持类的注册和查找

4. **实现基础的原生容器 (IntArray, IntList)**
   - 提供实用的集合类型
   - 验证对象模型的完整性

### 中期目标 (第1-2个月)

5. **实现运行时环境 (GorgeLanguageRuntime)**
   - 统一管理所有类型和对象
   - 为虚拟机实现做准备

6. **开始虚拟机核心实现**
   - 从简单的算术指令开始
   - 逐步扩展到控制流和方法调用

## 测试策略

### 单元测试
- 每个类和方法都有对应的测试
- 使用测试框架 (如 Google Test)
- 覆盖正常情况和边界情况

### 集成测试
- 测试 C++ 实现的整体功能
- 测试与 C# 实现的互操作性
- 性能基准测试

### 回归测试
- 确保修复不会引入新的问题
- 自动化测试套件
- 持续集成支持

## 风险与缓解

### 技术风险
1. **内存管理复杂性**
   - 缓解: 从智能指针开始，逐步优化
   - 使用内存分析工具早期检测问题

2. **性能未达预期**
   - 缓解: 早期性能基准测试
   - 使用性能剖析工具识别瓶颈

3. **与 C# 实现的不兼容**
   - 缓解: 保持 FFI 接口稳定
   - 编写兼容性测试套件

### 项目风险
1. **范围蔓延**
   - 缓解: 明确每个阶段的目标
   - 优先实现核心功能

2. **技术债务累积**
   - 缓解: 定期代码审查
   - 及时修复已知问题

## 总结

gorge_core 的 C++ 实现已经有了良好的基础。下一步的关键是:

1. **先修复，后扩展**: 确保现有代码的正确性
2. **循序渐进**: 从对象模型开始，逐步构建完整运行时
3. **保持兼容**: 确保与 C# 实现的平滑过渡
4. **重视测试**: 建立全面的测试体系

按照这个路线图，可以在 1-2 个月内实现一个基本可用的 gorge 语言运行时，为后续的虚拟机实现和高级功能打下坚实基础。